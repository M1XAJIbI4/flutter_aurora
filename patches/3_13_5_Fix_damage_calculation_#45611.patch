Subject: [PATCH] Fix damage calculation when not providing populate_existing_damage for gl embedder
---
Index: src/flutter/shell/platform/embedder/tests/embedder_gl_unittests.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/flutter/shell/platform/embedder/tests/embedder_gl_unittests.cc b/src/flutter/shell/platform/embedder/tests/embedder_gl_unittests.cc
--- a/src/flutter/shell/platform/embedder/tests/embedder_gl_unittests.cc	(revision bd986c5ed20a62dc34b7718c50abc782beae4c33)
+++ b/src/flutter/shell/platform/embedder/tests/embedder_gl_unittests.cc	(date 1696340417382)
@@ -3220,7 +3220,7 @@
 
   EmbedderConfigBuilder builder(context);
   builder.SetOpenGLRendererConfig(SkISize::Make(800, 600));
-  builder.SetDartEntrypoint("render_gradient");
+  builder.SetDartEntrypoint("render_gradient_retained");
   builder.GetRendererConfig().open_gl.populate_existing_damage =
       [](void* context, const intptr_t id,
          FlutterDamage* existing_damage) -> void {
@@ -3233,7 +3233,8 @@
       .SetGLPopulateExistingDamageCallback(
           [](const intptr_t id, FlutterDamage* existing_damage_ptr) {
             const size_t num_rects = 1;
-            FlutterRect existing_damage_rects[num_rects] = {
+            // The array must be valid after the callback returns.
+            static FlutterRect existing_damage_rects[num_rects] = {
                 FlutterRect{0, 0, 800, 600}};
             existing_damage_ptr->num_rects = num_rects;
             existing_damage_ptr->damage = existing_damage_rects;
@@ -3242,9 +3243,11 @@
   auto engine = builder.LaunchEngine();
   ASSERT_TRUE(engine.is_valid());
 
+  fml::AutoResetWaitableEvent latch;
+
   // First frame should be entirely rerendered.
   static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
-      [](FlutterPresentInfo present_info) {
+      [&](FlutterPresentInfo present_info) {
         const size_t num_rects = 1;
         ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
         ASSERT_EQ(present_info.frame_damage.damage->left, 0);
@@ -3257,6 +3260,8 @@
         ASSERT_EQ(present_info.buffer_damage.damage->top, 0);
         ASSERT_EQ(present_info.buffer_damage.damage->right, 800);
         ASSERT_EQ(present_info.buffer_damage.damage->bottom, 600);
+
+        latch.Signal();
       });
 
   // Send a window metrics events so frames may be scheduled.
@@ -3267,12 +3272,13 @@
   event.pixel_ratio = 1.0;
   ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
             kSuccess);
+  latch.Wait();
 
   // Because it's the same as the first frame, the second frame damage should
   // be empty but, because there was a full existing buffer damage, the buffer
   // damage should be the entire screen.
   static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
-      [](FlutterPresentInfo present_info) {
+      [&](FlutterPresentInfo present_info) {
         const size_t num_rects = 1;
         ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
         ASSERT_EQ(present_info.frame_damage.damage->left, 0);
@@ -3285,10 +3291,13 @@
         ASSERT_EQ(present_info.buffer_damage.damage->top, 0);
         ASSERT_EQ(present_info.buffer_damage.damage->right, 800);
         ASSERT_EQ(present_info.buffer_damage.damage->bottom, 600);
+
+        latch.Signal();
       });
 
   ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
             kSuccess);
+  latch.Wait();
 }
 
 TEST_F(EmbedderTest, PresentInfoReceivesEmptyDamage) {
@@ -3296,7 +3305,7 @@
 
   EmbedderConfigBuilder builder(context);
   builder.SetOpenGLRendererConfig(SkISize::Make(800, 600));
-  builder.SetDartEntrypoint("render_gradient");
+  builder.SetDartEntrypoint("render_gradient_retained");
   builder.GetRendererConfig().open_gl.populate_existing_damage =
       [](void* context, const intptr_t id,
          FlutterDamage* existing_damage) -> void {
@@ -3309,7 +3318,8 @@
       .SetGLPopulateExistingDamageCallback(
           [](const intptr_t id, FlutterDamage* existing_damage_ptr) {
             const size_t num_rects = 1;
-            FlutterRect existing_damage_rects[num_rects] = {
+            // The array must be valid after the callback returns.
+            static FlutterRect existing_damage_rects[num_rects] = {
                 FlutterRect{0, 0, 0, 0}};
             existing_damage_ptr->num_rects = num_rects;
             existing_damage_ptr->damage = existing_damage_rects;
@@ -3318,9 +3328,11 @@
   auto engine = builder.LaunchEngine();
   ASSERT_TRUE(engine.is_valid());
 
+  fml::AutoResetWaitableEvent latch;
+
   // First frame should be entirely rerendered.
   static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
-      [](FlutterPresentInfo present_info) {
+      [&](FlutterPresentInfo present_info) {
         const size_t num_rects = 1;
         ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
         ASSERT_EQ(present_info.frame_damage.damage->left, 0);
@@ -3333,6 +3345,8 @@
         ASSERT_EQ(present_info.buffer_damage.damage->top, 0);
         ASSERT_EQ(present_info.buffer_damage.damage->right, 800);
         ASSERT_EQ(present_info.buffer_damage.damage->bottom, 600);
+
+        latch.Signal();
       });
 
   // Send a window metrics events so frames may be scheduled.
@@ -3343,11 +3357,12 @@
   event.pixel_ratio = 1.0;
   ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
             kSuccess);
+  latch.Wait();
 
   // Because it's the same as the first frame, the second frame should not be
   // rerendered assuming there is no existing damage.
   static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
-      [](FlutterPresentInfo present_info) {
+      [&](FlutterPresentInfo present_info) {
         const size_t num_rects = 1;
         ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
         ASSERT_EQ(present_info.frame_damage.damage->left, 0);
@@ -3360,10 +3375,13 @@
         ASSERT_EQ(present_info.buffer_damage.damage->top, 0);
         ASSERT_EQ(present_info.buffer_damage.damage->right, 0);
         ASSERT_EQ(present_info.buffer_damage.damage->bottom, 0);
+
+        latch.Signal();
       });
 
   ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
             kSuccess);
+  latch.Wait();
 }
 
 TEST_F(EmbedderTest, PresentInfoReceivesPartialDamage) {
@@ -3371,7 +3389,7 @@
 
   EmbedderConfigBuilder builder(context);
   builder.SetOpenGLRendererConfig(SkISize::Make(800, 600));
-  builder.SetDartEntrypoint("render_gradient");
+  builder.SetDartEntrypoint("render_gradient_retained");
   builder.GetRendererConfig().open_gl.populate_existing_damage =
       [](void* context, const intptr_t id,
          FlutterDamage* existing_damage) -> void {
@@ -3382,9 +3400,10 @@
   // Return existing damage as only part of the screen on purpose.
   static_cast<EmbedderTestContextGL&>(context)
       .SetGLPopulateExistingDamageCallback(
-          [](const intptr_t id, FlutterDamage* existing_damage_ptr) {
+          [&](const intptr_t id, FlutterDamage* existing_damage_ptr) {
             const size_t num_rects = 1;
-            FlutterRect existing_damage_rects[num_rects] = {
+            // The array must be valid after the callback returns.
+            static FlutterRect existing_damage_rects[num_rects] = {
                 FlutterRect{200, 150, 400, 300}};
             existing_damage_ptr->num_rects = num_rects;
             existing_damage_ptr->damage = existing_damage_rects;
@@ -3393,9 +3412,11 @@
   auto engine = builder.LaunchEngine();
   ASSERT_TRUE(engine.is_valid());
 
+  fml::AutoResetWaitableEvent latch;
+
   // First frame should be entirely rerendered.
   static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
-      [](FlutterPresentInfo present_info) {
+      [&](FlutterPresentInfo present_info) {
         const size_t num_rects = 1;
         ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
         ASSERT_EQ(present_info.frame_damage.damage->left, 0);
@@ -3408,6 +3429,8 @@
         ASSERT_EQ(present_info.buffer_damage.damage->top, 0);
         ASSERT_EQ(present_info.buffer_damage.damage->right, 800);
         ASSERT_EQ(present_info.buffer_damage.damage->bottom, 600);
+
+        latch.Signal();
       });
 
   // Send a window metrics events so frames may be scheduled.
@@ -3418,12 +3441,13 @@
   event.pixel_ratio = 1.0;
   ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
             kSuccess);
+  latch.Wait();
 
   // Because it's the same as the first frame, the second frame damage should be
   // empty but, because there was a partial existing damage, the buffer damage
   // should represent that partial damage area.
   static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
-      [](FlutterPresentInfo present_info) {
+      [&](FlutterPresentInfo present_info) {
         const size_t num_rects = 1;
         ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
         ASSERT_EQ(present_info.frame_damage.damage->left, 0);
@@ -3436,10 +3460,13 @@
         ASSERT_EQ(present_info.buffer_damage.damage->top, 150);
         ASSERT_EQ(present_info.buffer_damage.damage->right, 400);
         ASSERT_EQ(present_info.buffer_damage.damage->bottom, 300);
+
+        latch.Signal();
       });
 
   ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
             kSuccess);
+  latch.Wait();
 }
 
 TEST_F(EmbedderTest, PopulateExistingDamageReceivesValidID) {
@@ -3447,7 +3474,7 @@
 
   EmbedderConfigBuilder builder(context);
   builder.SetOpenGLRendererConfig(SkISize::Make(800, 600));
-  builder.SetDartEntrypoint("render_gradient");
+  builder.SetDartEntrypoint("render_gradient_retained");
   builder.GetRendererConfig().open_gl.populate_existing_damage =
       [](void* context, const intptr_t id,
          FlutterDamage* existing_damage) -> void {
@@ -3465,6 +3492,8 @@
           [window_fbo_id = window_fbo_id](intptr_t id,
                                           FlutterDamage* existing_damage) {
             ASSERT_EQ(id, window_fbo_id);
+            existing_damage->num_rects = 0;
+            existing_damage->damage = nullptr;
           });
 
   // Send a window metrics events so frames may be scheduled.
@@ -3482,7 +3511,7 @@
 
   EmbedderConfigBuilder builder(context);
   builder.SetOpenGLRendererConfig(SkISize::Make(800, 600));
-  builder.SetDartEntrypoint("render_gradient");
+  builder.SetDartEntrypoint("render_gradient_retained");
   builder.GetRendererConfig().open_gl.populate_existing_damage =
       [](void* context, const intptr_t id,
          FlutterDamage* existing_damage) -> void {
@@ -3511,6 +3540,8 @@
           [window_fbo_id = window_fbo_id](intptr_t id,
                                           FlutterDamage* existing_damage) {
             ASSERT_NE(id, window_fbo_id);
+            existing_damage->num_rects = 0;
+            existing_damage->damage = nullptr;
           });
 
   // Send a window metrics events so frames may be scheduled.
@@ -4075,24 +4106,162 @@
   glFinish();
 }
 
+TEST_F(
+    EmbedderTest,
+    PresentInfoReceivesFullScreenDamageWhenPopulateExistingDamageIsNotProvided) {
+  auto& context = GetEmbedderContext(EmbedderTestContextType::kOpenGLContext);
+
+  EmbedderConfigBuilder builder(context);
+  builder.SetOpenGLRendererConfig(SkISize::Make(800, 600));
+  builder.SetDartEntrypoint("render_gradient_retained");
+  builder.GetRendererConfig().open_gl.populate_existing_damage = nullptr;
+
+  auto engine = builder.LaunchEngine();
+  ASSERT_TRUE(engine.is_valid());
+
+  fml::AutoResetWaitableEvent latch;
+
+  // First frame should be entirely rerendered.
+  static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
+      [&](FlutterPresentInfo present_info) {
+        const size_t num_rects = 1;
+        ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
+        ASSERT_EQ(present_info.frame_damage.damage->left, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->top, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->right, 800);
+        ASSERT_EQ(present_info.frame_damage.damage->bottom, 600);
+
+        ASSERT_EQ(present_info.buffer_damage.num_rects, num_rects);
+        ASSERT_EQ(present_info.buffer_damage.damage->left, 0);
+        ASSERT_EQ(present_info.buffer_damage.damage->top, 0);
+        ASSERT_EQ(present_info.buffer_damage.damage->right, 800);
+        ASSERT_EQ(present_info.buffer_damage.damage->bottom, 600);
+
+        latch.Signal();
+      });
+
+  // Send a window metrics events so frames may be scheduled.
+  FlutterWindowMetricsEvent event = {};
+  event.struct_size = sizeof(event);
+  event.width = 800;
+  event.height = 600;
+  event.pixel_ratio = 1.0;
+  ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
+            kSuccess);
+  latch.Wait();
+
+  // Since populate_existing_damage is not provided, the partial repaint
+  // functionality is actually disabled. So, the next frame should be entirely
+  // new frame.
+  static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
+      [&](FlutterPresentInfo present_info) {
+        const size_t num_rects = 1;
+        ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
+        ASSERT_EQ(present_info.frame_damage.damage->left, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->top, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->right, 800);
+        ASSERT_EQ(present_info.frame_damage.damage->bottom, 600);
+
+        ASSERT_EQ(present_info.buffer_damage.num_rects, num_rects);
+        ASSERT_EQ(present_info.buffer_damage.damage->left, 0);
+        ASSERT_EQ(present_info.buffer_damage.damage->top, 0);
+        ASSERT_EQ(present_info.buffer_damage.damage->right, 800);
+        ASSERT_EQ(present_info.buffer_damage.damage->bottom, 600);
+
+        latch.Signal();
+      });
+
+  ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
+            kSuccess);
+  latch.Wait();
+}
+
 TEST_F(EmbedderTest,
-       PresentInfoReceivesNoDamageWhenPopulateExistingDamageIsUndefined) {
+       PresentInfoReceivesJoinedDamageWhenExistingDamageContainsMultipleRects) {
   auto& context = GetEmbedderContext(EmbedderTestContextType::kOpenGLContext);
 
   EmbedderConfigBuilder builder(context);
   builder.SetOpenGLRendererConfig(SkISize::Make(800, 600));
-  builder.SetDartEntrypoint("render_gradient");
-  builder.GetRendererConfig().open_gl.populate_existing_damage = nullptr;
+  builder.SetDartEntrypoint("render_gradient_retained");
+  builder.GetRendererConfig().open_gl.populate_existing_damage =
+      [](void* context, const intptr_t id,
+         FlutterDamage* existing_damage) -> void {
+    return reinterpret_cast<EmbedderTestContextGL*>(context)
+        ->GLPopulateExistingDamage(id, existing_damage);
+  };
+
+  // Return existing damage as the entire screen on purpose.
+  static_cast<EmbedderTestContextGL&>(context)
+      .SetGLPopulateExistingDamageCallback(
+          [](const intptr_t id, FlutterDamage* existing_damage_ptr) {
+            const size_t num_rects = 2;
+            // The array must be valid after the callback returns.
+            static FlutterRect existing_damage_rects[num_rects] = {
+                FlutterRect{100, 150, 200, 250},
+                FlutterRect{200, 250, 300, 350},
+            };
+            existing_damage_ptr->num_rects = num_rects;
+            existing_damage_ptr->damage = existing_damage_rects;
+          });
 
   auto engine = builder.LaunchEngine();
   ASSERT_TRUE(engine.is_valid());
 
-  // No damage should be passed.
+  fml::AutoResetWaitableEvent latch;
+
+  // First frame should be entirely rerendered.
+  static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
+      [&](FlutterPresentInfo present_info) {
+        const size_t num_rects = 1;
+        ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
+        ASSERT_EQ(present_info.frame_damage.damage->left, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->top, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->right, 800);
+        ASSERT_EQ(present_info.frame_damage.damage->bottom, 600);
+
+        ASSERT_EQ(present_info.buffer_damage.num_rects, num_rects);
+        ASSERT_EQ(present_info.buffer_damage.damage->left, 0);
+        ASSERT_EQ(present_info.buffer_damage.damage->top, 0);
+        ASSERT_EQ(present_info.buffer_damage.damage->right, 800);
+        ASSERT_EQ(present_info.buffer_damage.damage->bottom, 600);
+
+        latch.Signal();
+      });
+
+  // Send a window metrics events so frames may be scheduled.
+  FlutterWindowMetricsEvent event = {};
+  event.struct_size = sizeof(event);
+  event.width = 800;
+  event.height = 600;
+  event.pixel_ratio = 1.0;
+  ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
+            kSuccess);
+  latch.Wait();
+
+  // Because it's the same as the first frame, the second frame damage should
+  // be empty but, because there was a full existing buffer damage, the buffer
+  // damage should be the entire screen.
   static_cast<EmbedderTestContextGL&>(context).SetGLPresentCallback(
-      [](FlutterPresentInfo present_info) {
-        ASSERT_EQ(present_info.frame_damage.damage, nullptr);
-        ASSERT_EQ(present_info.buffer_damage.damage, nullptr);
+      [&](FlutterPresentInfo present_info) {
+        const size_t num_rects = 1;
+        ASSERT_EQ(present_info.frame_damage.num_rects, num_rects);
+        ASSERT_EQ(present_info.frame_damage.damage->left, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->top, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->right, 0);
+        ASSERT_EQ(present_info.frame_damage.damage->bottom, 0);
+
+        ASSERT_EQ(present_info.buffer_damage.num_rects, num_rects);
+        ASSERT_EQ(present_info.buffer_damage.damage->left, 100);
+        ASSERT_EQ(present_info.buffer_damage.damage->top, 150);
+        ASSERT_EQ(present_info.buffer_damage.damage->right, 300);
+        ASSERT_EQ(present_info.buffer_damage.damage->bottom, 350);
+
+        latch.Signal();
       });
+
+  ASSERT_EQ(FlutterEngineSendWindowMetricsEvent(engine.get(), &event),
+            kSuccess);
+  latch.Wait();
 }
 
 INSTANTIATE_TEST_SUITE_P(
Index: src/flutter/shell/platform/embedder/fixtures/main.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/flutter/shell/platform/embedder/fixtures/main.dart b/src/flutter/shell/platform/embedder/fixtures/main.dart
--- a/src/flutter/shell/platform/embedder/fixtures/main.dart	(revision bd986c5ed20a62dc34b7718c50abc782beae4c33)
+++ b/src/flutter/shell/platform/embedder/fixtures/main.dart	(date 1696340206931)
@@ -1213,3 +1213,25 @@
 
   signalNativeTest();
 }
+
+@pragma('vm:entry-point')
+void render_gradient_retained() {
+  OffsetEngineLayer? offsetLayer; // Retain the offset layer.
+  PlatformDispatcher.instance.onBeginFrame = (Duration duration) {
+    Size size = Size(800.0, 600.0);
+
+    SceneBuilder builder = SceneBuilder();
+
+    offsetLayer = builder.pushOffset(0.0, 0.0, oldLayer: offsetLayer);
+
+    // display_list_layer will comparing the display_list
+    // no need to retain the picture
+    builder.addPicture(
+        Offset(0.0, 0.0), CreateGradientBox(size)); // gradient - flutter
+
+    builder.pop();
+
+    PlatformDispatcher.instance.views.first.render(builder.build());
+  };
+  PlatformDispatcher.instance.scheduleFrame();
+}
\ No newline at end of file
Index: src/flutter/shell/gpu/gpu_surface_gl_delegate.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/flutter/shell/gpu/gpu_surface_gl_delegate.h b/src/flutter/shell/gpu/gpu_surface_gl_delegate.h
--- a/src/flutter/shell/gpu/gpu_surface_gl_delegate.h	(revision bd986c5ed20a62dc34b7718c50abc782beae4c33)
+++ b/src/flutter/shell/gpu/gpu_surface_gl_delegate.h	(date 1696340126295)
@@ -27,8 +27,6 @@
 struct GLFBOInfo {
   // The frame buffer's ID.
   uint32_t fbo_id;
-  // This boolean flags whether the returned FBO supports partial repaint.
-  const bool partial_repaint_enabled;
   // The frame buffer's existing damage (i.e. damage since it was last used).
   const std::optional<SkIRect> existing_damage;
 };
Index: src/flutter/shell/platform/embedder/embedder.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/flutter/shell/platform/embedder/embedder.cc b/src/flutter/shell/platform/embedder/embedder.cc
--- a/src/flutter/shell/platform/embedder/embedder.cc	(revision bd986c5ed20a62dc34b7718c50abc782beae4c33)
+++ b/src/flutter/shell/platform/embedder/embedder.cc	(date 1696340417434)
@@ -341,8 +341,7 @@
     if (!populate_existing_damage) {
       return flutter::GLFBOInfo{
           .fbo_id = static_cast<uint32_t>(id),
-          .partial_repaint_enabled = false,
-          .existing_damage = SkIRect::MakeEmpty(),
+          .existing_damage = std::nullopt,
       };
     }
 
@@ -350,29 +349,22 @@
     FlutterDamage existing_damage;
     populate_existing_damage(user_data, id, &existing_damage);
 
-    bool partial_repaint_enabled = true;
-    SkIRect existing_damage_rect;
+    std::optional<SkIRect> existing_damage_rect = std::nullopt;
 
     // Verify that at least one damage rectangle was provided.
     if (existing_damage.num_rects <= 0 || existing_damage.damage == nullptr) {
       FML_LOG(INFO) << "No damage was provided. Forcing full repaint.";
-      existing_damage_rect = SkIRect::MakeEmpty();
-      partial_repaint_enabled = false;
-    } else if (existing_damage.num_rects > 1) {
-      // Log message notifying users that multi-damage is not yet available in
-      // case they try to make use of it.
-      FML_LOG(INFO) << "Damage with multiple rectangles not yet supported. "
-                       "Repainting the whole frame.";
+    } else {
       existing_damage_rect = SkIRect::MakeEmpty();
-      partial_repaint_enabled = false;
-    } else {
-      existing_damage_rect = FlutterRectToSkIRect(*(existing_damage.damage));
+      for (size_t i = 0; i < existing_damage.num_rects; i++) {
+        existing_damage_rect->join(
+            FlutterRectToSkIRect(existing_damage.damage[i]));
+      }
     }
 
     // Pass the information about this FBO to the rendering backend.
     return flutter::GLFBOInfo{
         .fbo_id = static_cast<uint32_t>(id),
-        .partial_repaint_enabled = partial_repaint_enabled,
         .existing_damage = existing_damage_rect,
     };
   };
Index: src/flutter/shell/platform/android/android_surface_gl_skia.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/flutter/shell/platform/android/android_surface_gl_skia.cc b/src/flutter/shell/platform/android/android_surface_gl_skia.cc
--- a/src/flutter/shell/platform/android/android_surface_gl_skia.cc	(revision bd986c5ed20a62dc34b7718c50abc782beae4c33)
+++ b/src/flutter/shell/platform/android/android_surface_gl_skia.cc	(date 1696340126307)
@@ -166,7 +166,6 @@
   // The default window bound framebuffer on Android.
   return GLFBOInfo{
       .fbo_id = 0,
-      .partial_repaint_enabled = onscreen_surface_->SupportsPartialRepaint(),
       .existing_damage = onscreen_surface_->InitialDamage(),
   };
 }
